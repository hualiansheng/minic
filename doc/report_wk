类型检查
类型检查中为了方便类型转换和记录类型，声明了一个新的类型struct data_type，保存并传递变量和表达式的类型。检查时利用了遍历模型，深度优先遍历语法树，遇到表达式时转为自底向上检查。类型检查的原则基本依据gcc。

1.对于每个表达式，若其中有一部分类型检查返回的类型为错误类型，则直接返回错误类型。
2.对于赋值语句，若赋值两边的表达式类型不相同，则要进行必要的转换或者报错：
  若赋值符号左边为指针类型，但size为-1,则说明是数组类型，报错;
  若两边一边为指针，另一边为int或者char，则报warning;
  若两边均为指针或者均非指针，则正常返回op1的类型，除非op1的类型为char且op2的类型为int，此时报warning并返回op1的类型。
3.对于lvalue，分以下情况：
	若lvalue为一个变量，则在符号表中检查这个id，没找到则报错，找到了则正常返回一个代表该变量类型data_type变量，否则报错。另外，还要判断一下该变量的类型，若为void类型或者声明为函数类型同样报错。
	若lvalue为一个指针的解引用，则判断对应的被解引用的rvalue是否是一个指针类型，若是则将返回的data_type变量类型置为普通类型（非指针）。
	若lvalue为一个数组元素，则首先检查此lvalue对应的4个树节点中，第一个元素是否为指针类型，若不是则报错。其次检查数组下标对应的元素是否是一个非指针的int型表达式或者一个char型表达式，若不是则报错。返回对应数组元素类型即可。
4.对于rvalue，检查时情况较多
	若语法树上rvalue节点对应的子节点为两个元素，说明对应的表达式为一个单目运算符和一个操作数，则调用函数对单目运算符表达式进行类型检查。
	单目运算符：
	对于正号和负号，判断其操作数是否是int型变量或char型变量，若不是则报错。
	对于取非运算符！，返回一个int型的类型
	对于自增运算符++和自减运算符--，若其操作数为数组变量，则报错，否则返回一个与操作数相同的类型。

	若语法树上rvalue节点对应的字节点为三个元素，则rvalue应该是一个无参的函数调用或者一个双目运算符的表达式。若是一个函数调用，则在符号表中检查该id，若该id不是声明为一个无参函数则报错，否则返回函数返回值对应的类型。
	若是一个双目运算符的表达式，则调用函数对双目运算符表达式进行类型检查。
	双目运算符：
	对于关系运算符（>，<，==，<=，>=，!=），检查两个操作数的类型，若不完全相同则报warning，最终返回一个int类型。
	对于bool型op(||，&&)，检查两个操作数类型，若不完全相同则报warning，最终返回一个int类型。
	对于减法运算，需要报错的情况有：第一个操作数非指针，第二个操作数是指针；两个操作数均为指针，但是两个操作数一个为int型另一个为char型。
	对于加法运算，只有当两个操作数均为指针时需要报错，其它情况进行必要的类型转换即可。
	对于乘法运算，当两个操作数任何一个为指针时报错，否则进行必要的类型转换并返回即可。

	若语法树上rvalue节点对应的字节点为四个元素，则说明是含参数的函数调用。这种情况先递归地求出所有参数类型，然后检查参数个数，若调用的参数个数与函数在符号表中的函数个数不符，则报错。否则若参数类型和函数在符号表中的参数的类型不同，则报warning。


中间代码（表达式）：
1. bool表达式
bool表达式的翻译涉及到短路问题。另外由于语法要求，在实现短路的同时也要实现bool表达式的求值。由于我们使用了三元式，故需要用一个专用的变量来记录bool表达式的值。我们利用了两个中间代码上的运算：set_rb和get_rb，用来记录bool表达式的值。
以“||”连接的两项的bool表达式为例，在bool表达式开始求值之前，先将rb置为1，然后开始计算bool表达式左边一项的值。之后根据左边这项的值进行判断，若值为非0，则此项为真，短路条件成立故直接跳转到这个bool表达式的尾部；否则，短路条件不成立，继续对bool表达式右边一项求值。若第二项的值使得整个bool表达式值为1，则跳转到bool表达式尾部；否则，将bool表达式置为0。在bool表达式的结尾处，利用get_rb将bool表达式的值赋给一个临时变量。对于“&&”连接的bool表达式，反之即可。对于多项的bool表达式，由于我们语法树的结构，只需要递归的对bool表达式逐项翻译即可。

2. 赋值表达式
赋值表达式的翻译涉及到变量赋值和地址赋值两种不同的情况。由于我们建立的语法树上区分了lvalue和rvalue，故我们需要对lvalue的情况进行讨论。若lvalue为一个变量，那么一直以变量名来代表这个lvalue。若lvalue为一个地址对应的值，如指针的解引用或者数组元素，那么应该用一个地址值来代表这个lvalue，而当这个lvalue转化为rvalue时，应该把其值转化为内存地址上对应的数据。
在规定了lvalue的类型和翻译方法后，即可对赋值语句进行翻译。对于变量赋值的情况，只需要对表达式逐项翻译即可。如果lvalue是对地址类型的解引用，例如数组元素或者对指针类型的解引用，我们用一个中间代码上的操作star_assign(*=)来翻译这种情况。
