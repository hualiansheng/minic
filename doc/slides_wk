消除冗余MOV语句
example：

add	r4,	r4,	r5
mov r5,	r4
add r7, r4,	1
ldw	r4, [r6+], #4

result：
add	r5,	r4,	r5
add r7, r5,	1
ldw	r4, [r6+], #4

冗余的mov语句主要来自于读取内存的操作（和中间代码的形式有关）。
方法：
1.对目标代码划分基本块（以跳转指令为标志），并在基本块上做一个简单的跳转关系图，每个基本块中记录每个它接下来可能执行的基本块。
2.扫描代码。对每个mov语句，其目标寄存器为Rd(mov)，源寄存器为Rm(mov)。从该条语句向上寻找最近一条语句i，语句i的目标寄存器为Rm(mov)。（语句i对Rm(mov)定值）
3.判断语句i是否可以被删除。原则有：
a.若mov语句到语句i之间有对Rd(mov)的引用，则不可删除。
b.从语句i开始，根据跳转关系图向后扫描代码（深度优先的遍历）。若进入循环块则停止，语句i不可删除。
c.扫描过程中，若某调语句引用了Rm(mov)，则将它替换为Rd(mov)。若某条语句对Rm(mov)定值，则这条扫描路径终止。若某条语句对Rd(mov)定值，并在这之后又引用Rm(mov)，则扫描停止，语句i不可删除。
4.若上述扫描完成后，没有出现语句i不可删除的情况，则删除mov语句，将语句i的目标寄存器改为Rd(mov)。

可以删除的条件：
1.从mov指令的源操作数最近的一次定值开始，到mov指令之间没有对mov的目标操作数引用。
2.从mov指令开始，将mov指令的源操作数替换为目标操作数时不会产生冲突。



指令调度
example:
	ldw	r4, [r6+], #4
	add	r5, r4, r5
	ldw	r4, [r6+], #4
	sub	r4, r4, r5
	ldw	r30, [r27+], #-4
	1->2, 1->3, 1->4, 1->5, 2->4, 3->4, 3->5, 
result:
	ldw	r4, [r6+], #4
	add	r5, r4, r5
	ldw	r4, [r6+], #4
	ldw	r30, [r27+], #-4
	sub	r4, r4, r5
指令调度：依据目标代码基本块内的数据依赖关系，调整指令顺序，以便消除ldw指令之后插入的空指令。
方法：
1.在目标代码上划分基本块（以跳转指令和标签作为标记）。指令调度在基本块内完成。
2.对每个基本块，根据指令间的数据依赖关系，建立数据依赖图。若指令i的源操作数依赖于指令j的执行结果，则建立j到i的一条边。
3.根据数据依赖图，进行变种的拓扑排序：扫描块中所有指令。遇到ldw指令，则开始执行所有ldw指令依赖的指令（即在图上可达这条ldw指令的指令）；之后，从所有本块中未执行过的指令中取出一条入度为0的指令（不依赖于任何指令），排在这条ldw指令后面。特别地，这条指令的源操作数应该尽量和ldw指令的目标操作数不相等。
4.扫描一遍ldw指令之后，所有可能调开的ldw指令都已经被调开。再对未执行的指令进行拓扑排序即可。
