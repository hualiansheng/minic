CPU设计文档
一、流水结构
五级流水：
取指（IF）--译码（读寄存器）（ID）--ALU计算（EX）--访存（MEM）--写回（WB）

二、需要解决的冒险
1、结构冒险：通过指令cache和数据cache分离的Havard结构解决
2、数据冒险：
	1）数据转发机制解决一部分冒险问题
	2）但是“加载-使用型数据冒险”需要加一个气泡
3、控制冒险：
	分支控制导致的冒险：用分支预测的方法来解决：
	分支预测的策略:a.B指令一定预测跳转，b.其他条件跳转指令预测不跳转


三、各个模块的设计和接口规范
1、IF（Instruction Fetch）
输入：指令地址
输出：struct
实现：直接对cache进行访问，分为命中和未命中两种情况
Q1：cache命中和未命中会造成不同的时间延迟，这一点是如何处理的？

2、ID（Instruction Decode）
输入：IF的输出
输出：struct
实现：对指令进行译码，获得对应寄存器的值，寄存器的编号，操作类型、操作数、移位立即数的值等等并保存在结构体中

3、Ex（Execuation）
输入：ID的输出
输出：struct
实现：根据指令的类型进行相应的运算，对于R型指令，写回在此处进行（即在此处进行数据转发）；对于分支指令，分支预测在此处进行处理。

4、Mem（Memory）
输入：Ex的输出
输出：struct
实现：lw指令的写回在此处实现，其他指令到此处均已执行完毕

5、WB（Write Back）
所有指令均已经执行完毕，此模块不做任何事情

四、各模块调用次序及相关结构的定义
1、各模块在逻辑上是并行的，在实现上是从后向前调用，遇到需要插入气泡的情况直接阻塞前边的各级流水
2、三中所述的结构：
typedef struct{
  uint32_t inst_code;
  uint32_t opcodes;
  int inst_type;
  uint32_t operand1, operant2;
  int32_t *dest_reg;
  int imm;
  int shift;
  int rotate;
  int cond;
  int high_offset, low_offset;
  int S, A, P, U, B, W, L, H;
}PIPLINE_DATA;



